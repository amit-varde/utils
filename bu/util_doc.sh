#!/bin/bash
# -----------------------------------------------------------------------------
# File: bu/util_doc.sh
# Author: Generated by GitHub Copilot
# -----------------------------------------------------------------------------
# Description: Utility functions for generating documentation using GitHub Copilot.
# -----------------------------------------------------------------------------
# Check if util_bash is loaded
[[ -z "${BASH_UTILS_LOADED}" ]] && { echo "ERROR: util_bash.sh is not loaded. Please source it before using this script."; exit 1; }

#==============================================================================
# DOCUMENTATION GENERATION FUNCTIONS
#==============================================================================

# -----------------------------------------------------------------------------
doc_generate_for_file() { # Generate documentation for a specific file using GitHub Copilot
    local file="$1"
    local output_file="${2:-""}"
    local doc_style="${3:-"standard"}"
    
    # Validate input
    if [ -z "$file" ]; then
        err "No file specified. Usage: doc_generate_for_file <file> [output_file] [doc_style]"
        return 1
    fi
    
    if [ ! -f "$file" ]; then
        err "File '$file' does not exist."
        return 1
    fi
    
    # Check if GitHub CLI is installed
    if ! command -v gh >/dev/null 2>&1; then
        err "GitHub CLI is not installed. Please install it first: https://cli.github.com/manual/installation"
        return 1
    fi
    
    # Check if GitHub Copilot extension is installed
    if ! gh extension list | grep -q "github/gh-copilot"; then
        err "GitHub Copilot extension is not installed. Please install it using 'gh extension install github/gh-copilot'"
        return 1
    fi
    
    info "Generating documentation for '$file' using style: $doc_style"
    
    # Create a temporary file for the prompt
    local prompt_file=$(mktemp /tmp/doc-prompt-XXXXXX)
    
    # Build the prompt based on the documentation style
    case "$doc_style" in
        "standard")
            echo "Generate comprehensive documentation for the following code file. Include:" > "$prompt_file"
            echo "1. A brief description of what the file does" >> "$prompt_file"
            echo "2. Documentation for each function/class/method" >> "$prompt_file"
            echo "3. Usage examples where appropriate" >> "$prompt_file"
            echo "4. Notes about any dependencies or assumptions" >> "$prompt_file"
            echo "Format the documentation in markdown." >> "$prompt_file"
            ;;
        "jsdoc")
            echo "Generate JSDoc style comments for the following JavaScript/TypeScript code:" > "$prompt_file"
            echo "Include @param, @returns, @throws tags where appropriate." >> "$prompt_file"
            ;;
        "pydoc")
            echo "Generate Python docstrings (using Google style) for the following Python code:" > "$prompt_file"
            echo "Include parameters, return values, exceptions, and examples." >> "$prompt_file"
            ;;
        "javadoc")
            echo "Generate Javadoc style comments for the following Java code:" > "$prompt_file"
            echo "Include @param, @return, @throws tags where appropriate." >> "$prompt_file"
            ;;
        *)
            echo "Generate clear and comprehensive documentation for the code below:" > "$prompt_file"
            ;;
    esac
    
    echo "" >> "$prompt_file"
    echo "File: $(basename "$file")" >> "$prompt_file"
    echo "```" >> "$prompt_file"
    cat "$file" >> "$prompt_file"
    echo "```" >> "$prompt_file"
    
    # Generate documentation using GitHub Copilot
    info "Sending request to GitHub Copilot..."
    
    if [ -z "$output_file" ]; then
        # Display to terminal if no output file is specified
        gh copilot explain < "$prompt_file" | less
    else
        # Save to the output file
        info "Saving documentation to '$output_file'..."
        gh copilot explain < "$prompt_file" > "$output_file"
        
        # Check if the output was successfully generated
        if [ -s "$output_file" ]; then
            info "Documentation successfully generated and saved to '$output_file'"
        else
            err "Failed to generate documentation"
            rm -f "$output_file"  # Remove empty output file
            rm -f "$prompt_file"  # Clean up prompt file
            return 1
        fi
    fi
    
    # Clean up temporary file
    rm -f "$prompt_file"
    
    return 0
}

# -----------------------------------------------------------------------------
doc_comment_file() { # Add inline comments to a file using GitHub Copilot
    local file="$1"
    local output_file="${2:-""}"
    
    # Validate input
    if [ -z "$file" ]; then
        err "No file specified. Usage: doc_comment_file <file> [output_file]"
        return 1
    fi
    
    if [ ! -f "$file" ]; then
        err "File '$file' does not exist."
        return 1
    fi
    
    # Check if GitHub CLI is installed
    if ! command -v gh >/dev/null 2>&1; then
        err "GitHub CLI is not installed. Please install it first: https://cli.github.com/manual/installation"
        return 1
    fi
    
    # Check if GitHub Copilot extension is installed
    if ! gh extension list | grep -q "github/gh-copilot"; then
        err "GitHub Copilot extension is not installed. Please install it using 'gh extension install github/gh-copilot'"
        return 1
    fi
    
    info "Adding inline comments to '$file'..."
    
    # Create a temporary file for the prompt
    local prompt_file=$(mktemp /tmp/doc-prompt-XXXXXX)
    
    # Build the prompt
    echo "Add detailed inline comments to the following code to explain what it does." > "$prompt_file"
    echo "Be thorough but concise. Preserve the original code structure exactly." >> "$prompt_file"
    echo "Return the code with added comments only, not explanations about the comments." >> "$prompt_file"
    echo "" >> "$prompt_file"
    echo "```" >> "$prompt_file"
    cat "$file" >> "$prompt_file"
    echo "```" >> "$prompt_file"
    
    # Generate commented code using GitHub Copilot
    info "Sending request to GitHub Copilot..."
    
    if [ -z "$output_file" ]; then
        # Create a default output filename with .commented extension
        output_file="${file}.commented"
    fi
    
    # Save to the output file
    info "Saving commented code to '$output_file'..."
    gh copilot suggest < "$prompt_file" | sed -n '/```/,/```/p' | sed '1d;$d' > "$output_file"
    
    # Check if the output was successfully generated
    if [ -s "$output_file" ]; then
        info "Comments successfully added and saved to '$output_file'"
    else
        err "Failed to generate commented code"
        rm -f "$output_file"  # Remove empty output file
        rm -f "$prompt_file"  # Clean up prompt file
        return 1
    fi
    
    # Clean up temporary file
    rm -f "$prompt_file"
    
    return 0
}

# -----------------------------------------------------------------------------
doc_summarize_file() { # Generate a concise summary of a file's functionality
    local file="$1"
    
    # Validate input
    if [ -z "$file" ]; then
        err "No file specified. Usage: doc_summarize_file <file>"
        return 1
    fi
    
    # Check if file exists and is readable
    if [ ! -f "$file" ] || [ ! -r "$file" ]; then
        err "File '$file' does not exist or is not readable."
        return 1
    fi
    
    # Check if GitHub CLI is installed
    if ! command -v gh >/dev/null 2>&1; then
        err "GitHub CLI is not installed. Please install it first: https://cli.github.com/manual/installation"
        return 1
    fi
    
    # Check if GitHub Copilot extension is installed
    if ! gh extension list | grep -q "github/gh-copilot"; then
        err "GitHub Copilot extension is not installed. Please install it using 'gh extension install github/gh-copilot'"
        return 1
    fi
    
    info "Generating summary for '$file'..."
    
    # Create a temporary file for the content
    local temp_file=$(mktemp /tmp/file-content-XXXXXX)
    
    # Copy the file content to the temporary file
    cat "$file" > "$temp_file" 2>/dev/null || { 
        err "Failed to read file content from '$file'"; 
        rm -f "$temp_file"; 
        return 1; 
    }
    
    # GitHub Copilot CLI is interactive and doesn't work well with pipes
    # Let's provide instructions to the user
    echo ""
    echo "In the GitHub Copilot prompt that appears:"
    echo "1. Type: summarize this file in 5 bullet points"
    echo "2. Press Enter"
    echo ""
    # Show the temporary file path
    info "Using temporary file: $temp_file"
    # Display the content of the file for reference
    echo "File contents:"
    echo "----------------------------------------"
    cat "$temp_file"
    echo "----------------------------------------"
    echo ""

    # Launch gh copilot with the file
    gh copilot explain "$temp_file"
    
    # Clean up temporary file
    #rm -f "$temp_file"
    
    return 0
}

# -----------------------------------------------------------------------------
doc_batch_process() { # Generate documentation for multiple files in a directory
    local dir="$1"
    local file_pattern="${2:-"*"}"
    local doc_style="${3:-"standard"}"
    
    # Validate input
    if [ -z "$dir" ]; then
        err "No directory specified. Usage: doc_batch_process <directory> [file_pattern] [doc_style]"
        return 1
    fi
    
    if [ ! -d "$dir" ]; then
        err "Directory '$dir' does not exist."
        return 1
    fi
    
    info "Batch processing files in '$dir' matching pattern '$file_pattern'..."
    
    # Create output directory for documentation
    local docs_dir="$dir/docs"
    mkdir -p "$docs_dir"
    
    # Find and process matching files
    find "$dir" -maxdepth 1 -type f -name "$file_pattern" | while read -r file; do
        # Skip files in docs directory
        if [[ "$file" == *"/docs/"* ]]; then
            continue
        fi
        
        local filename=$(basename "$file")
        local output_file="$docs_dir/${filename}.md"
        
        info "Processing file: $filename"
        doc_generate_for_file "$file" "$output_file" "$doc_style"
    done
    
    info "Batch processing complete. Documentation saved in '$docs_dir'"
    
    return 0
}

# -----------------------------------------------------------------------------
# If loading is successful this will be executed
# Always makes sure this is the last function call
type list_bash_functions_in_file >/dev/null 2>&1 && list_bash_functions_in_file "$(realpath "$0")" || err "alias is not loaded"
# -----------------------------------------------------------------------------
