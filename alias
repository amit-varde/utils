# -----------------------------------------------------------------------------
# File: alias
# Author: Amit
# Email: tercel04@gmail.com; amit@bazinga-labs.com
# -----------------------------------------------------------------------------
# Description:
# This file contains aliases and functions useful for everyday tasks.
# -----------------------------------------------------------------------------
# Usage:
# Add the following at the bottom of your ~/.zshrc
# alias so='source ~/.zshrc;echo "ZSH aliases sourced."'
# ALIAS_FILE="$HOME/work/utils/alias"
# [ -f "$ALIAS_FILE" ] && source "$ALIAS_FILE" || echo "Alias file $ALIAS_FILE not found"
# Save ~/.zshrc
# source ~/.zshrc
# Everytime there is a new alias file, run "so" on the terminal to source it
# -----------------------------------------------------------------------------
# Notes:
# Naming conventions
# Functions have _ : e.g., my_function
# Aliases have - : e.g., my-alias
# -----------------------------------------------------------------------------
# Icon variables for status indicators
export ICON_WARNING="‚ö†Ô∏è"
export ICON_GREEN_CHECK="‚úÖ"
export ICON_RED_CROSS="‚ùå"
export ICON_THUMBS_DOWN="üëé"
export ICON_THUMBS_UP="üëç"
export ICON_RED_ALERT="üö®"
# -----------------------------------------------------------------------------
# Directories
export DOCS="$HOME/Documents"
export DL="$HOME/Downloads"
export iDL="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Downloads"
export iDOCS="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Documents"
export WORK="$HOME/work"
export UTILS="$WORK/utils"
export JNBS="$WORK/jupyter-notebooks"

#BASH Utils
export BASH_UTILS_SRC="$HOME/work/utils/src/"
export BASH_UTILS_LOADED=""
# -----------------------------------------------------------------------------
# Organized Alias Definitions (one-line description)
alias w='cd $WORK'               # Navigate to work directory
alias docs='cd $DOCS'            # Navigate to documents directory
alias dl='cd $DL'                # Navigate to downloads directory
alias utils='cd $UTILS'          # Navigate to utilities directory
alias idl='cd $iDL'              # Navigate to iCloud downloads directory
alias idoc='cd $iDOCS'           # Navigate to iCloud documents directory
alias up='cd ..'                 # Navigate up one directory
alias lr='ls -lrt'               # List files in long format, sorted by modification time
alias la='ls -a'                 # List all files including hidden files
alias l1='ls -1'                 # List files in single column
alias lock='chmod -R 700'        # Set restrictive permissions (700) on files/directories
alias unlock='chmod -R 755'      # Set standard permissions (755) on files/directories
alias mkexe='chmod -R 755'       # Make files executable with permission 755
alias x='exit'                   # Exit the terminal
alias c='clear'                  # Clear the terminal screen
alias cls='clear'                # Clear the terminal screen
alias m='more'                   # View file content page by page
alias h='head -20'               # Show first 20 lines of a file
alias t='tail -20'               # Show last 20 lines of a file
alias g='grep -i'                # Case-insensitive text search with grep
alias clean-temp-files='rm -f *~ .*~ *.swp *.swo *.bak *.tmp *.orig *.rej'  # Remove backup and temporary files
alias clean-pycache='find . -type d -name "__pycache__" -exec rm -rf {} +'       # Clean Python cache directories
alias fname='realpath'
alias dname='dirname $(realpath)'

# -----------------------------------------------------------------------------
# Organized Function Definitions (one-line description)
check_path() {   # Display PATH entries and check for duplicates
    RED="\033[1;31m"
    BLUE="\033[1;34m"
    GREEN="\033[1;32m"
    RESET="\033[0m"
    
    if [ -z "$1" ]; then
        # No input - display all PATH entries
        echo -e "${BLUE}All PATH entries:${RESET}"
        echo "$PATH" | tr ":" "\n" | nl -w2 -s" : "

        # Find and display duplicates
        echo -e "${BLUE}Checking for duplicates:${RESET}"
        duplicates=$(echo "$PATH" | tr ":" "\n" | sort | uniq -d)

        if [ -z "$duplicates" ]; then
            echo -e -n "${GREEN}No duplicates found in PATH${RESET}"
        else
            echo -e "${RED}Found duplicates:${RESET}"
            # Process each duplicate path
            echo "$duplicates" | while read -r dup; do
                positions=""
                index=1
                
                # Find all positions of this duplicate in PATH
                while IFS= read -r entry; do
                    if [ "$entry" = "$dup" ]; then
                        if [ -z "$positions" ]; then
                            positions="$index"
                        else
                            positions="$positions, $index"
                        fi
                    fi
                    ((index++))
                done < <(echo "$PATH" | tr ":" "\n")
                
                # Print with correct format
                echo "  $dup: [$positions]"
            done
        fi
    else
        # Search input provided - only show matches
        echo -e "\n${BLUE}Searching for \"$1\" in PATH:${RESET}"
        while read -r line; do
            if echo "$line" | grep -q "$1"; then
                # Path contains search term - display in red
                echo -e "${RED}$line${RESET}"
            else
                # Path doesn't contain search term - display in green
                echo -e "${GREEN}$line${RESET}"
            fi
        done < <(echo "$PATH" | tr ":" "\n" | nl -w2 -s" : ")
    fi
}
# -----------------------------------------------------------------------------
check_ld_library_path() {   # Display LD_LIBRARY_PATH entries and check for duplicates
    RED="\033[1;31m"
    BLUE="\033[1;34m"
    GREEN="\033[1;32m"
    RESET="\033[0m"
    
    if [ -z "$1" ]; then
        # No input - display all LD_LIBRARY_PATH entries
        echo -e "${BLUE}All LD_LIBRARY_PATH entries:${RESET}"
        echo "$LD_LIBRARY_PATH" | tr ":" "\n" | nl -w2 -s" : "

        # Find and display duplicates
        echo -e "${BLUE}Checking for duplicates:${RESET}"
        duplicates=$(echo "$LD_LIBRARY_PATH" | tr ":" "\n" | sort | uniq -d)

        if [ -z "$duplicates" ]; then
            echo -e -n "${GREEN}No duplicates found in LD_LIBRARY_PATH${RESET}"
        else
            echo -e "${RED}Found duplicates:${RESET}"
            # Process each duplicate path
            echo "$duplicates" | while read -r dup; do
                positions=""
                index=1
                
                # Find all positions of this duplicate in LD_LIBRARY_PATH
                while IFS= read -r entry; do
                    if [ "$entry" = "$dup" ]; then
                        if [ -z "$positions" ]; then
                            positions="$index"
                        else
                            positions="$positions, $index"
                        fi
                    fi
                    ((index++))
                done < <(echo "$LD_LIBRARY_PATH" | tr ":" "\n")
                
                # Print with correct format
                echo "  $dup: [$positions]"
            done
        fi
    else
        # Search input provided - only show matches
        echo -e "\n${BLUE}Searching for \"$1\" in LD_LIBRARY_PATH:${RESET}"
        while read -r line; do
            if echo "$line" | grep -q "$1"; then
                # Path contains search term - display in red
                echo -e "${RED}$line${RESET}"
            else
                # Path doesn't contain search term - display in green
                echo -e "${GREEN}$line${RESET}"
            fi
        done < <(echo "$LD_LIBRARY_PATH" | tr ":" "\n" | nl -w2 -s" : ")
    fi
}
# -----------------------------------------------------------------------------
setup_graphviz_env() {   # Set up Graphviz environment variables
    [[ ":$PATH:" != *":/usr/local/opt/graphviz/bin:"* ]] && export PATH="/usr/local/opt/graphviz/bin:$PATH"
}
# -----------------------------------------------------------------------------
clean_temp_files() {   # Clean temporary files with feedback
    echo "Cleaning temporary files..."
    rm -f *~ .*~ *.swp *.swo *.bak *.tmp *.orig *.rej
    echo "Temporary files cleaned."
}
# -----------------------------------------------------------------------------
run() {   # Run a Python script with arguments and save output to run.out
    clear
    local script="$1"
    local output_file="run.out"
    shift
    [ -z "$script" ] && { echo "Error: No Python script specified."; return 1; }
    [ ! -f "$script" ] && { echo "Error: Python script '$script' does not exist."; return 1; }
    echo "Running Python script '$script' with arguments: $*"
    python "$script" "$@" | tee "$output_file"
    [ $? -eq 0 ] && echo "$ICON_GREEN_CHECK Script executed successfully. Output redirected to '$output_file'." || echo "Script execution failed. Check '$output_file' for details."
}
# -----------------------------------------------------------------------------
change_prompt() {   # Change the shell prompt to show project name
    #local current_dir=$(basename "$PWD")
    prompt_prefix=${PROJECT_NAME:-"NONE"}
    export PROMPT="($prompt_prefix) %~> "
}
# -----------------------------------------------------------------------------
## PYENV
# Install PYENV and .env both
# brew install pyenv
export PYENV_ROOT="$HOME/.pyenv"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init - zsh)"
# -----------------------------------------------------------------------------
mypy() {   # Display Python environment information
    echo "Python should be managed by pyenv"
    pyenv_version=$(pyenv --version 2>&1)
    echo "Pyenv version: $pyenv_version"
    python_path=$(which python)
    python_version=$(python --version 2>&1)
    echo "Python executable: $python_path"
    echo "Python version: $python_version"
    pip_path=$(which pip)
    pip_version=$(pip --version 2>&1)
    echo "Pip executable: $pip_path"
    echo "Pip version: $pip_version"
    if [ -z "$VIRTUAL_ENV" ]; then
        echo "No virtual environment is currently activated."
    else
        echo "Current virtual environment: $VIRTUAL_ENV"
    fi
}
# -----------------------------------------------------------------------------
list_bash_functions_in_file() {   # List all bash functions in this file with descriptions
    local script_path="$1"
    echo "Functions defined in [$(basename "$script_path")]: "
    # Use grep to find function definitions with inline comments
    fs=$(grep -E '^[a-zA-Z0-9_]+\(\)\ *\{\ *#' "$script_path")
    # Find the maximum length of function names
    max_len=0
    while IFS= read -r line; do
        # Extract function name (before #) and remove (), {}
        func_name=$(echo "$line" | sed 's/#.*$//' | tr -d '(){}' | xargs)
        if [ ${#func_name} -gt $max_len ]; then
            max_len=${#func_name}
        fi
    done <<< "$fs"
    
    # Print with aligned comments
    while IFS= read -r line; do
        func_name=$(echo "$line" | sed 's/#.*$//' | tr -d '(){}' | xargs)
        description=$(echo "$line" | sed 's/^[^#]*#//')
        printf " %-${max_len}s :%s\n" "$func_name" "$description"
    done <<< "$fs"
}

list_alias_in_file() {   # List all alias definitions in this file with descriptions
    local script_path="$1"
    echo "Aliases defined in [$(basename "$script_path")]: "
    # Use grep to find alias definitions that include an inline comment for description
    as=$(grep -E '^alias [^=]+=.*#' "$script_path")
    # Find the maximum length of alias names
    max_len=0
    while IFS= read -r line; do
        # Extract alias name located between 'alias' and the '=' sign
        alias_name=$(echo "$line" | sed -E 's/^alias[[:space:]]+([^=]+)=.*$/\1/' | xargs)
        if [ ${#alias_name} -gt $max_len ]; then
            max_len=${#alias_name}
        fi
    done <<< "$as"
    
    # Print alias names with aligned descriptions
    while IFS= read -r line; do
        alias_name=$(echo "$line" | sed -E 's/^alias[[:space:]]+([^=]+)=.*$/\1/' | xargs)
        description=$(echo "$line" | sed 's/.*#//')
        printf " %-${max_len}s :%s\n" "$alias_name" "$description"
    done <<< "$as"
}
# -----------------------------------------------------------------------------
# Bash utilities loader functions have been moved to util_bash.sh
# -----------------------------------------------------------------------------
go_project() {   # Navigate to a project directory and set up its environment
    [ -z "$1" ] && { echo "Error: No project name provided."; return 1; }
    local project_name="$1"
    [ ! -d "$WORK/$project_name" ] && { echo "Error: Project '$project_name' does not exist under $WORK."; return 1; }
    if [ -n "$PROJECT_NAME" ]; then
        echo "Deactivating current project: $PROJECT_NAME"
        deactivate 2>/dev/null || echo "No virtual environment to deactivate."
        unset PROJECT_NAME
    fi
    cd "$WORK/$project_name" || return 1
    [ -f venv/bin/activate ] && source venv/bin/activate
    [ -f "${project_name}.env" ] && source "${project_name}.env"
    mypy
    if [[ "$TERM_PROGRAM" != "vscode" ]]; then
        [ -f "$project_name".code-workspace ] && code "$project_name".code-workspace
    fi
    export PROJECT_NAME="$project_name"
    change_prompt
}
# -----------------------------------------------------------------------------
gen_alias_projects() {   # Generate aliases for all projects in the WORK directory
    echo "Generating project aliases..."
    for dir in "$WORK"/*/; do
        [ -d "$dir" ] || continue
        project_name=$(basename "$dir")
        alias "go-$project_name"="go_project $project_name"
        echo "  go-$project_name: $WORK/$project_name"
    done
}
# -----------------------------------------------------------------------------
# Lets reconfigure alias to open file with Vscode when inside the vscode terminal
alias open &>/dev/null && unalias open
[[ "$TERM_PROGRAM" == "vscode" ]] && alias open="code"
# -----------------------------------------------------------------------------
# Adding functions to autogenerate aliases
gen_alias_projects
# -----------------------------------------------------------------------------
# Final setup
[ -d "$WORK" ] && cd "$WORK" || cd "$HOME"
PROMPT="%n@%m:%~> "

# Source the bash utilities file if it exists
BASH_UTILS_FILE="$BASH_UTILS_SRC/util_bash.sh"
[ -f "$BASH_UTILS_FILE" ] && source "$BASH_UTILS_FILE" || echo "$ICON_WARNING Bash utils file $BASH_UTILS_FILE not found"
echo "Loaded amit's alias file"
# -----------------------------------------------------------------------------