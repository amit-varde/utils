# -----------------------------------------------------------------------------
# File: alias
# Author: Amit
# Email: tercel04@gmail.com; amit@bazinga-labs.com
# -----------------------------------------------------------------------------
# Description:
# This file contains aliases and functions that are useful for everyday tasks.
# -----------------------------------------------------------------------------
# File Version Info: 
#
# -----------------------------------------------------------------------------
# Usage:
# Add the following at the bottom of your ~/.zshrc
# alias so='source ~/.zshrc;echo "ZSH aliases sourced."'
# ALIAS_FILE="$HOME/work/utils/alias"
# [ -f "$ALIAS_FILE" ] && source "$ALIAS_FILE" || echo "Alias file $ALIAS_FILE not found"
# Save ~/.zshrc
# source ~/.zshrc
# Everytime there is a new alias file, run "so" on the terminal to source it
#######################
# Notes:
# Naming conventions
# Functions have _ : e.g., my_function
# Aliases have - : e.g., my-alias
# -----------------------------------------------------------------------------

# Directories
export DOCS="$HOME/Documents"
export DL="$HOME/Downloads"
export iDL="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Downloads"
export iDOCS="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Documents"
export WORK="$HOME/work"
export UTILS="$WORK/utils"
export JNBS="$WORK/jupyter-notebooks"

alias w='cd $WORK'
alias docs='cd $DOCS'
alias dl='cd $DL'
alias utils='cd $UTILS'
alias idl='cd $iDL'
alias idoc='cd $iDOCS'


# Changing file permissions
alias lock='chmod -R 700'
alias unlock='chmod -R 755'
alias mkexe='chmod -R 755'

# ls
alias lr='ls -lrt'
alias la='ls -a'
alias l1='ls -1'
alias rd='rm -rf'
alias rz='rm *~'
alias rx='rm #*#'
alias up='cd ..'

alias x='exit'
alias c='clear'
alias cls='clear'
alias m='more'
alias h='head -20'
alias t='tail -20'
alias g='grep -i'

alias check-path='echo "$PATH" | tr ":" "\n"'
alias check-ld-library-path='echo "$LD_LIBRARY_PATH" | tr ":" "\n"'
alias clean-temp-files='rm -f *~ .*~ *.swp *.swo *.bak *.tmp *.orig *.rej'

# -----------------------------------------------------------------------------
# Git alias and functions
git_file_info() {
    local file="$1"
    [ -z "$file" ] && { echo "Error: No file specified."; return 1; }
    [ ! -f "$file" ] && { echo "Error: File '$file' does not exist."; return 1; }
    echo "File Version Info: $file"
    echo "Version: $(git log -n 1 --pretty=format:"%h" -- "$file")"
    echo "Last Updated: $(git log -n 1 --pretty=format:"%ad" --date=short -- "$file")"
    echo "Last Update Message: $(git log -n 1 --pretty=format:"%s" -- "$file")"
    local git_sha=$(git log -n 1 --pretty=format:"%h" -- "$file")
    local local_sha=$(shasum -a 256 "$file" | awk '{print $1}')
    local git_file_content=$(git show "$git_sha:$file" 2>/dev/null | shasum -a 256 | awk '{print $1}')

    echo "Tags: $(git tag --contains $git_sha | tr '\n' ' ')"
    echo "SHA (Git): $git_file_content"

        if [ "$local_sha" != "$git_file_content" ]; then
            echo "Status: MODIFIED"
            echo "SHA (Local): $local_sha (modified)"
        else
            echo "Status: UNCHANGED"
            echo "SHA (Local): $local_sha"
        fi
}

git_file_history() {
    local file="$1"
    [ -z "$file" ] && { echo "Error: No file specified."; return 1; }
    [ ! -f "$file" ] && { echo "Error: File '$file' does not exist."; return 1; }
    echo "Git history for file: $file"
    git log --follow --pretty=format:"%h | %ad | %s" --date=short -- "$file" | tee /dev/stdout
}
git_diff_with_latest() {
    local file="$1"
    [ -z "$file" ] && { echo "Error: No file specified."; return 1; }
    [ ! -f "$file" ] && { echo "Error: File '$file' does not exist."; return 1; }
    echo "Diffing '$file' with the latest version on this branch..."
    git fetch origin
    git diff --color-words --diff-algorithm=patience -- "$(git merge-base HEAD origin/$(git rev-parse --abbrev-ref HEAD))" -- "$file" | diff-so-fancy
}
# -----------------------------------------------------------------------------
## PYENV
# Install PYENV and .env both
# brew install pyenv
export PYENV_ROOT="$HOME/.pyenv"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init - zsh)"
alias clean-pycache='find . -type d -name "__pycache__" -exec rm -rf {} +'
# -----------------------------------------------------------------------------
# Python-related aliases and functions

init_venv() {
    if [ -d "venv" ]; then
        echo "Virtual environment already exists in the current directory."
        read -p "Do you want to recreate it? (y/n): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo "Operation canceled."
            return 1
        fi
        rm -rf venv
        echo "Existing virtual environment removed."
    fi

    python -m venv venv
    if [ $? -eq 0 ]; then
        echo "Virtual environment created successfully."
        source venv/bin/activate
        echo "Virtual environment activated."
    else
        echo "Failed to create virtual environment."
        return 1
    fi
}
alias clean-pip-cache='pip cache purge'
alias pip-list='pip list --format=columns'
alias pip-list-outdated='pip list --outdated --format=columns'

pip_diff_requirements() {
    local req_file="requirements.txt"
    local temp_req_file="tmp_requirements.txt"
    if [ ! -f "$req_file" ]; then
        echo "Error: Requirements file '$req_file' does not exist."
        return 1
    fi
    if [ -f "$temp_req_file" ]; then
        echo "Error: Temporary requirements file '$temp_req_file' already exists."
        return 1
    fi
    echo "Comparing '$temp_req_file' with '$req_file'..."
    code --diff "$temp_req_file" "$req_file"
}
pip_overwrite_requirements_file() {
    local req_file="requirements.txt"
    local tmp_req_file="tmp_requirements.txt"
    local backup_dir=".backup_requirements.txt"
    local date=$(date +"%Y%m%d_%H%M%S")

    [ ! -f "$req_file" ] && { echo "Error: Requirements file '$req_file' does not exist."; return 1; }
    [ ! -f "$tmp_req_file" ] && { echo "Error: Temporary requirements file '$tmp_req_file' does not exist."; return 1; }
    mkdir -p "$backup_dir"
    my "$req_file" "$backup_dir/requirements_$date.txt"
    [ $? -eq 0 ] && echo "Backup created at '$backup_dir/requirements_$date.txt'." || { echo "Failed to create backup."; return 1; }
    echo "Overwriting '$req_file'..."
    mv "$tmp_req_file" "$req_file"
    [ $? -eq 0 ] && echo "'$req_file' has been overwritten successfully." || { echo "Failed to overwrite '$req_file'."; return 1; }
}
mypy() {
    echo "Python should be managed by pyenv"
    
    pyenv_version=$(pyenv --version 2>&1)
    echo "Pyenv version: $pyenv_version"

    python_path=$(which python)
    python_version=$(python --version 2>&1)
    echo "Python executable: $python_path"
    echo "Python version: $python_version"
    
    pip_path=$(which pip)
    pip_version=$(pip --version 2>&1)
    echo "Pip executable: $pip_path"
    echo "Pip version: $pip_version"

    if [ -z "$VIRTUAL_ENV" ]; then
        echo "No virtual environment is currently activated."
    else
        echo "Current virtual environment: $VIRTUAL_ENV"
    fi
}

change_prompt() {
    #local current_dir=$(basename "$PWD")
    prompt_prefix=${PROJECT_NAME:-"NONE"}
    export PROMPT="($prompt_prefix) %~> "
}


# -----------------------------------------------------------------------------
# Project-related functions and aliases

go_project() {
    [ -z "$1" ] && { echo "Error: No project name provided."; return 1; }
    local project_name="$1"
    [ ! -d "$WORK/$project_name" ] && { echo "Error: Project '$project_name' does not exist under $WORK."; return 1; }
    if [ -n "$PROJECT_NAME" ]; then
        echo "Deactivating current project: $PROJECT_NAME"
        deactivate 2>/dev/null || echo "No virtual environment to deactivate."
        unset PROJECT_NAME
    fi
    cd "$WORK/$project_name" || return 1
    [ -f venv/bin/activate ] && source venv/bin/activate
    [ -f "${project_name}.env" ] && source "${project_name}.env"
    mypy
    export PROJECT_NAME="$project_name"
    change_prompt
}

generate_project_aliases() {
    echo "Generating project aliases..."
    for dir in "$WORK"/*/; do
        [ -d "$dir" ] || continue
        project_name=$(basename "$dir")
        alias "go-$project_name"="go_project $project_name"
        echo "  go-$project_name: $WORK/$project_name"
    done
}
redefine_so_alias() {
    if alias so &>/dev/null; then
        if [ -n "$PROJECT_NAME" ]; then
            alias so='source ~/.zshrc; echo "ZSH aliases sourced. Current project: $PROJECT_NAME"'
            echo "Alias 'so' redefined to include current project: $PROJECT_NAME"
        fi
    else
        echo "Alias 'so' is not defined."
    fi
}
generate_project_aliases

# -----------------------------------------------------------------------------
# Jupyter Notebook

jupyter_notebook() {
    local notebook_dir="$JNBS"
    if [ -z "$notebook_dir" ]; then
        notebook_dir="."
    fi
    if [ ! -d "$notebook_dir" ]; then
        echo "Directory $notebook_dir does not exist."
        return 1
    fi
    cd "$notebook_dir" || return 1
    echo "Launching Jupyter Notebook in directory: $notebook_dir"
    jupyter notebook
}

# -----------------------------------------------------------------------------
# Drexel Environment Setup

setup_drexel_env() {
    [[ ":$PATH:" != *":/usr/local/opt/graphviz/bin:"* ]] && export PATH="/usr/local/opt/graphviz/bin:$PATH"
}

# -----------------------------------------------------------------------------
# Final setup
[ -d "$WORK" ] && cd "$WORK" || cd "$HOME"
PROMPT="%n@%m:%~> "
echo "Loaded amit's alias file"
# -----------------------------------------------------------------------------
