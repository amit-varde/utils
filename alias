# -----------------------------------------------------------------------------
# File: alias
# Author: Amit
# Email: tercel04@gmail.com; amit@bazinga-labs.com
# -----------------------------------------------------------------------------
# Description:
# This file contains aliases and functions that are useful for everyday tasks.
# -----------------------------------------------------------------------------
# File Version Info: 
#
# -----------------------------------------------------------------------------
# Usage:
# Add the following at the bottom of your ~/.zshrc
# alias so='source ~/.zshrc;echo "ZSH aliases sourced."'
# ALIAS_FILE="$HOME/work/utils/alias"
# [ -f "$ALIAS_FILE" ] && source "$ALIAS_FILE" || echo "Alias file $ALIAS_FILE not found"
# Save ~/.zshrc
# source ~/.zshrc
# Everytime there is a new alias file, run "so" on the terminal to source it
#######################
# Notes:
# Naming conventions
# Functions have _ : e.g., my_function
# Aliases have - : e.g., my-alias
# -----------------------------------------------------------------------------

# Directories
export DOCS="$HOME/Documents"
export DL="$HOME/Downloads"
export iDL="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Downloads"
export iDOCS="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Documents"
export WORK="$HOME/work"
export UTILS="$WORK/utils"
export JNBS="$WORK/jupyter-notebooks"

alias w='cd $WORK'
alias docs='cd $DOCS'
alias dl='cd $DL'
alias utils='cd $UTILS'
alias idl='cd $iDL'
alias idoc='cd $iDOCS'


# Changing file permissions
alias lock='chmod -R 700'
alias unlock='chmod -R 755'
alias mkexe='chmod -R 755'

# ls
alias lr='ls -lrt'
alias la='ls -a'
alias l1='ls -1'
alias rd='rm -rf'
alias rz='rm *~'
alias rx='rm #*#'
alias up='cd ..'

alias x='exit'
alias c='clear'
alias cls='clear'
alias m='more'
alias h='head -20'
alias t='tail -20'
alias g='grep -i'

# -----------------------------------------------------------------------------
# Env Check aliases
alias check-path='echo "$PATH" | tr ":" "\n"'
alias check-ld-library-path='echo "$LD_LIBRARY_PATH" | tr ":" "\n"'
# -----------------------------------------------------------------------------
# Functions to specifically setup certain environment variables
setup_graphviz_env() {
    [[ ":$PATH:" != *":/usr/local/opt/graphviz/bin:"* ]] && export PATH="/usr/local/opt/graphviz/bin:$PATH"
}
# -----------------------------------------------------------------------------
# Cleaning-related aliases and functions
alias clean-temp-files='rm -f *~ .*~ *.swp *.swo *.bak *.tmp *.orig *.rej'
alias clean-pycache='find . -type d -name "__pycache__" -exec rm -rf {} +'
alias clean-pip-cache='pip cache purge'
clean_temp_files() {
    echo "Cleaning temporary files..."
    rm -f *~ .*~ *.swp *.swo *.bak *.tmp *.orig *.rej
    echo "Temporary files cleaned."
}
# -----------------------------------------------------------------------------
# Related to running code
run() {
    clear
    local script="$1"
    local output_file="run.out"
    shift
    [ -z "$script" ] && { echo "Error: No Python script specified."; return 1; }
    [ ! -f "$script" ] && { echo "Error: Python script '$script' does not exist."; return 1; }
    echo "Running Python script '$script' with arguments: $*"
    python "$script" "$@" | tee "$output_file"
    [ $? -eq 0 ] && echo "Script executed successfully. Output redirected to '$output_file'." || echo "Script execution failed. Check '$output_file' for details."
    open "$output_file"
}
# -----------------------------------------------------------------------------



# -----------------------------------------------------------------------------
# Git alias and functions
git_file_info() {
    local file="$1"
    [ -z "$file" ] && { echo "Error: No file specified."; return 1; }
    [ ! -f "$file" ] && { echo "Error: File '$file' does not exist."; return 1; }
    echo "File Version Info: $file"
    echo "Version: $(git log -n 1 --pretty=format:"%h" -- "$file")"
    echo "Last Updated: $(git log -n 1 --pretty=format:"%ad" --date=short -- "$file")"
    echo "Last Update Message: $(git log -n 1 --pretty=format:"%s" -- "$file")"
    local git_sha=$(git log -n 1 --pretty=format:"%h" -- "$file")
    local local_sha=$(shasum -a 256 "$file" | awk '{print $1}')
    local git_file_content=$(git show "$git_sha:$file" 2>/dev/null | shasum -a 256 | awk '{print $1}')

    echo "Tags: $(git tag --contains $git_sha | tr '\n' ' ')"
    echo "SHA (Git): $git_file_content"

        if [ "$local_sha" != "$git_file_content" ]; then
            echo "Status: MODIFIED"
            echo "SHA (Local): $local_sha (modified)"
        else
            echo "Status: UNCHANGED"
            echo "SHA (Local): $local_sha"
        fi
}

git_file_history() {
    local file="$1"
    [ -z "$file" ] && { echo "Error: No file specified."; return 1; }
    [ ! -f "$file" ] && { echo "Error: File '$file' does not exist."; return 1; }
    echo "Git history for file: $file"
    git log --follow --pretty=format:"%h | %ad | %s" --date=short -- "$file" | tee /dev/stdout
}
git_diff_with_latest() {
    local file="$1"
    [ -z "$file" ] && { echo "Error: No file specified."; return 1; }
    [ ! -f "$file" ] && { echo "Error: File '$file' does not exist."; return 1; }
    echo "Diffing '$file' with the latest version on this branch..."
    git fetch origin
    git diff --color-words --diff-algorithm=patience -- "$(git merge-base HEAD origin/$(git rev-parse --abbrev-ref HEAD))" -- "$file" | diff-so-fancy
}
# -----------------------------------------------------------------------------
## PYENV
# Install PYENV and .env both
# brew install pyenv
export PYENV_ROOT="$HOME/.pyenv"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init - zsh)"
# -----------------------------------------------------------------------------
# Python-related aliases and functions
init_venv() {
    if [ -d "venv" ]; then
        echo "Virtual environment already exists in the current directory."
        read -p "Do you want to recreate it? (y/n): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo "Operation canceled."
            return 1
        fi
        rm -rf venv
        echo "Existing virtual environment removed."
    fi

    python -m venv venv
    if [ $? -eq 0 ]; then
        echo "Virtual environment created successfully."
        source venv/bin/activate
        echo "Virtual environment activated."
    else
        echo "Failed to create virtual environment."
        return 1
    fi
}
# -----------------------------------------------------------------------------
# pip-related aliases and functions
alias pip-list='pip list --format=columns'
alias pip-list-outdated='pip list --outdated --format=columns'
pip_diff_requirements() {
    local req_file="requirements.txt"
    local temp_req_file="tmp_requirements.txt"
    if [ ! -f "$req_file" ]; then
        echo "Error: Requirements file '$req_file' does not exist."
        return 1
    fi
    if [ -f "$temp_req_file" ]; then
        echo "Error: Temporary requirements file '$temp_req_file' already exists."
        return 1
    fi
    echo "Comparing '$temp_req_file' with '$req_file'..."
    code --diff "$temp_req_file" "$req_file"
}
pip_overwrite_requirements_file() {
    local req_file="requirements.txt"
    local tmp_req_file="tmp_requirements.txt"
    local backup_dir=".backup_requirements.txt"
    local date=$(date +"%Y%m%d_%H%M%S")

    [ ! -f "$req_file" ] && { echo "Error: Requirements file '$req_file' does not exist."; return 1; }
    [ ! -f "$tmp_req_file" ] && { echo "Error: Temporary requirements file '$tmp_req_file' does not exist."; return 1; }
    mkdir -p "$backup_dir"
    my "$req_file" "$backup_dir/requirements_$date.txt"
    [ $? -eq 0 ] && echo "Backup created at '$backup_dir/requirements_$date.txt'." || { echo "Failed to create backup."; return 1; }
    echo "Overwriting '$req_file'..."
    mv "$tmp_req_file" "$req_file"
    [ $? -eq 0 ] && echo "'$req_file' has been overwritten successfully." || { echo "Failed to overwrite '$req_file'."; return 1; }
}
mypy() {
    echo "Python should be managed by pyenv"
    
    pyenv_version=$(pyenv --version 2>&1)
    echo "Pyenv version: $pyenv_version"

    python_path=$(which python)
    python_version=$(python --version 2>&1)
    echo "Python executable: $python_path"
    echo "Python version: $python_version"
    
    pip_path=$(which pip)
    pip_version=$(pip --version 2>&1)
    echo "Pip executable: $pip_path"
    echo "Pip version: $pip_version"

    if [ -z "$VIRTUAL_ENV" ]; then
        echo "No virtual environment is currently activated."
    else
        echo "Current virtual environment: $VIRTUAL_ENV"
    fi
}
brew_versions_report() {
# Function: brew_versions_report
# Description: Generates a report of installed Homebrew formula packages, their versions, and update status.
# Dependencies: Homebrew, jq (install with `brew install jq`).
# Output: A table with columns - Package, Installed Version, Latest Version, Status (UP_TO_DATE/NEEDS_UPGRADE).
# Behavior: Checks for jq, iterates through installed packages, compares versions, and formats results into a table.
# Check for jq dependency
    if ! command -v jq &> /dev/null; then
        echo "Error: jq is required. Install it using: brew install jq"
        return 1
    fi

    echo "Package, Installed Version, Latest Version, Status"

    # Get information for all installed formula packages
    info=$(brew info --json=v2 --installed)
    # Parse the JSON data to extract installed and latest versions
    installed_versions=$(echo "$info" | jq -r '.formulae[] | .name + "," + (.installed[0].version // "Not Installed")')
    latest_versions=$(echo "$info" | jq -r '.formulae[] | .name + "," + (.versions.stable // "Unknown")')
    # Combine installed and latest versions, and determine the status
    while IFS= read -r installed; do
        package=$(echo "$installed" | cut -d',' -f1)
        installed_version=$(echo "$installed" | cut -d',' -f2)
        latest_version=$(echo "$latest_versions" | grep "^$package," | cut -d',' -f2)

        if [ "$installed_version" == "$latest_version" ]; then
            status="UP_TO_DATE"
        else
            status="NEEDS_UPGRADE"
        fi

        echo "$package, $installed_version, $latest_version, $status"
    done <<< "$installed_versions" | column -t -s ','

}
pip_versions_report() {
    # Function: pip_versions_report
    # Description: Generates a report of installed pip packages, their versions, and update status.
    # Output: A table with columns - Package, Installed Version, Latest Version, Status (UP_TO_DATE/NEEDS_UPGRADE).
    # Behavior: Iterates through installed pip packages, fetches the latest versions from PyPI, and formats results into a table.
    echo "Package, Installed Version, Latest Version, Status" | column -t -s ','
    # Get the list of installed pip packages and their versions
    installed_packages=$(pip list --format=freeze)

    # Iterate through each installed package
    while IFS= read -r package_info; do
        package=$(echo "$package_info" | cut -d'=' -f1)
        installed_version=$(echo "$package_info" | cut -d'=' -f3)
        latest_version=$(pip index versions "$package" 2>&1 | grep -o 'Available versions:.*' | cut -d':' -f2 | awk '{print $1}')
        if [ "$installed_version" == "$latest_version" ]; then
            status="UP_TO_DATE"
        else
            status="NEEDS_UPGRADE"
        fi
        echo "$package, $installed_version, $latest_version, $status"
    done <<< "$installed_packages" | column -t -s ','
}
change_prompt() {
    #local current_dir=$(basename "$PWD")
    prompt_prefix=${PROJECT_NAME:-"NONE"}
    export PROMPT="($prompt_prefix) %~> "
}


# -----------------------------------------------------------------------------
# Project-related functions and aliases
go_project() {
    [ -z "$1" ] && { echo "Error: No project name provided."; return 1; }
    local project_name="$1"
    [ ! -d "$WORK/$project_name" ] && { echo "Error: Project '$project_name' does not exist under $WORK."; return 1; }
    if [ -n "$PROJECT_NAME" ]; then
        echo "Deactivating current project: $PROJECT_NAME"
        deactivate 2>/dev/null || echo "No virtual environment to deactivate."
        unset PROJECT_NAME
    fi
    cd "$WORK/$project_name" || return 1
    [ -f venv/bin/activate ] && source venv/bin/activate
    [ -f "${project_name}.env" ] && source "${project_name}.env"
    mypy
    [ -f "$project_name".code-workspace ] && code "$project_name".code-workspace

    export PROJECT_NAME="$project_name"
    change_prompt
}
# -----------------------------------------------------------------------------
gen_alias_projects() {
    echo "Generating project aliases..."
    for dir in "$WORK"/*/; do
        [ -d "$dir" ] || continue
        project_name=$(basename "$dir")
        alias "go-$project_name"="go_project $project_name"
        echo "  go-$project_name: $WORK/$project_name"
    done
}
con_alias_open() {
    alias open &>/dev/null && unalias open
    [[ "$TERM_PROGRAM" == "vscode" ]] && alias open="code"
    #alias open &>/dev/null && echo "Alias for open: $(alias open)"
}
# -----------------------------------------------------------------------------
# Adding functions to autogenerate aliases
gen_alias_projects
con_alias_open

# -----------------------------------------------------------------------------
# Final setup
[ -d "$WORK" ] && cd "$WORK" || cd "$HOME"
PROMPT="%n@%m:%~> "
echo "Loaded amit's alias file"
# -----------------------------------------------------------------------------
