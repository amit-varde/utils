# -----------------------------------------------------------------------------
# File: alias
# Author: Amit
# Email: tercel04@gmail.com; amit@bazinga-labs.com
# -----------------------------------------------------------------------------
# Description:
# This file contains aliases and functions useful for everyday tasks.
# -----------------------------------------------------------------------------
# Usage:
# Add the following at the bottom of your ~/.zshrc
# alias so='source ~/.zshrc;echo "ZSH aliases sourced."'
# ALIAS_FILE="$HOME/work/utils/alias"
# [ -f "$ALIAS_FILE" ] && source "$ALIAS_FILE" || echo "Alias file $ALIAS_FILE not found"
# Save ~/.zshrc
# source ~/.zshrc
# Everytime there is a new alias file, run "so" on the terminal to source it
# -----------------------------------------------------------------------------
# Notes:
# Naming conventions
# Functions have _ : e.g., my_function
# Aliases have - : e.g., my-alias
# -----------------------------------------------------------------------------
# Color definitions
export RED="\033[1;31m"
export BLUE="\033[1;34m"
export GREEN="\033[1;32m"
export RESET="\033[0m"
# -----------------------------------------------------------------------------
# Directories
export DOCS="$HOME/Documents"
export DL="$HOME/Downloads"
export iDL="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Downloads"
export iDOCS="$HOME/Library/Mobile Documents/com~apple~CloudDocs/Documents"
export WORK="$HOME/work"
export UTILS="$WORK/utils"
export JNBS="$WORK/jupyter-notebooks"
export BASH_UTILS_SRC="$UTILS/src"  # Source directory for bash utilities

# -----------------------------------------------------------------------------
# Organized Alias Definitions (one-line description)
alias w='cd $WORK'               # Navigate to work directory
alias docs='cd $DOCS'            # Navigate to documents directory
alias dl='cd $DL'                # Navigate to downloads directory
alias utils='cd $UTILS'          # Navigate to utilities directory
alias idl='cd $iDL'              # Navigate to iCloud downloads directory
alias idoc='cd $iDOCS'           # Navigate to iCloud documents directory
alias up='cd ..'                 # Navigate up one directory
alias lr='ls -lrt'               # List files in long format, sorted by modification time
alias la='ls -a'                 # List all files including hidden files
alias l1='ls -1'                 # List files in single column
alias lock='chmod -R 700'        # Set restrictive permissions (700) on files/directories
alias unlock='chmod -R 755'      # Set standard permissions (755) on files/directories
alias mkexe='chmod -R 755'       # Make files executable with permission 755
alias x='exit'                   # Exit the terminal
alias c='clear'                  # Clear the terminal screen
alias cls='clear'                # Clear the terminal screen
alias m='more'                   # View file content page by page
alias h='head -20'               # Show first 20 lines of a file
alias t='tail -20'               # Show last 20 lines of a file
alias g='grep -i'                # Case-insensitive text search with grep
alias clean-temp-files='rm -f *~ .*~ *.swp *.swo *.bak *.tmp *.orig *.rej'  # Remove backup and temporary files
alias clean-pycache='find . -type d -name "__pycache__" -exec rm -rf {} +'       # Clean Python cache directories
alias clean-pip-cache='pip cache purge'  # Clear pip cache
alias fname='realpath'
alias dname='dirname $(realpath)'

# -----------------------------------------------------------------------------
# Organized Function Definitions (one-line description)
check_path() {   # Display PATH entries and check for duplicates    
    if [ -z "$1" ]; then
        # No input - display all PATH entries
        echo -e "${BLUE}All PATH entries:${RESET}"
        echo "$PATH" | tr ":" "\n" | nl -w2 -s" : "

        # Find and display duplicates
        echo -e "${BLUE}Checking for duplicates:${RESET}"
        duplicates=$(echo "$PATH" | tr ":" "\n" | sort | uniq -d)

        if [ -z "$duplicates" ]; then
            echo -e -n "${GREEN}No duplicates found in PATH${RESET}"
        else
            echo -e "${RED}Found duplicates:${RESET}"
            # Process each duplicate path
            echo "$duplicates" | while read -r dup; do
                positions=""
                index=1
                
                # Find all positions of this duplicate in PATH
                while IFS= read -r entry; do
                    if [ "$entry" = "$dup" ]; then
                        if [ -z "$positions" ]; then
                            positions="$index"
                        else
                            positions="$positions, $index"
                        fi
                    fi
                    ((index++))
                done < <(echo "$PATH" | tr ":" "\n")
                
                # Print with correct format
                echo "  $dup: [$positions]"
            done
        fi
    else
        # Search input provided - only show matches
        echo -e "\n${BLUE}Searching for \"$1\" in PATH:${RESET}"
        while read -r line; do
            if echo "$line" | grep -q "$1"; then
                # Path contains search term - display in red
                echo -e "${RED}$line${RESET}"
            else
                # Path doesn't contain search term - display in green
                echo -e "${GREEN}$line${RESET}"
            fi
        done < <(echo "$PATH" | tr ":" "\n" | nl -w2 -s" : ")
    fi
}
# -----------------------------------------------------------------------------
check_ld_library_path() {   # Display LD_LIBRARY_PATH entries and check for duplicates
    if [ -z "$1" ]; then
        # No input - display all LD_LIBRARY_PATH entries
        echo -e "${BLUE}All LD_LIBRARY_PATH entries:${RESET}"
        echo "$LD_LIBRARY_PATH" | tr ":" "\n" | nl -w2 -s" : "

        # Find and display duplicates
        echo -e "${BLUE}Checking for duplicates:${RESET}"
        duplicates=$(echo "$LD_LIBRARY_PATH" | tr ":" "\n" | sort | uniq -d)

        if [ -z "$duplicates" ]; then
            echo -e -n "${GREEN}No duplicates found in LD_LIBRARY_PATH${RESET}"
        else
            echo -e "${RED}Found duplicates:${RESET}"
            # Process each duplicate path
            echo "$duplicates" | while read -r dup; do
                positions=""
                index=1
                
                # Find all positions of this duplicate in LD_LIBRARY_PATH
                while IFS= read -r entry; do
                    if [ "$entry" = "$dup" ]; then
                        if [ -z "$positions" ]; then
                            positions="$index"
                        else
                            positions="$positions, $index"
                        fi
                    fi
                    ((index++))
                done < <(echo "$LD_LIBRARY_PATH" | tr ":" "\n")
                
                # Print with correct format
                echo "  $dup: [$positions]"
            done
        fi
    else
        # Search input provided - only show matches
        echo -e "\n${BLUE}Searching for \"$1\" in LD_LIBRARY_PATH:${RESET}"
        while read -r line; do
            if echo "$line" | grep -q "$1"; then
                # Path contains search term - display in red
                echo -e "${RED}$line${RESET}"
            else
                # Path doesn't contain search term - display in green
                echo -e "${GREEN}$line${RESET}"
            fi
        done < <(echo "$LD_LIBRARY_PATH" | tr ":" "\n" | nl -w2 -s" : ")
    fi
}
# -----------------------------------------------------------------------------
setup_graphviz_env() {   # Set up Graphviz environment variables
    [[ ":$PATH:" != *":/usr/local/opt/graphviz/bin:"* ]] && export PATH="/usr/local/opt/graphviz/bin:$PATH"
}
# -----------------------------------------------------------------------------
clean_temp_files() {   # Clean temporary files with feedback
    echo -e "${BLUE}Cleaning temporary files...${RESET}"
    rm -f *~ .*~ *.swp *.swo *.bak *.tmp *.orig *.rej
    echo -e "${GREEN}Temporary files cleaned.${RESET}"
}
# -----------------------------------------------------------------------------
run() {   # Run a Python script with arguments and save output to run.out
    clear
    local script="$1"
    local output_file="run.out"
    shift
    [ -z "$script" ] && { echo -e "${RED}Error: No Python script specified.${RESET}"; return 1; }
    [ ! -f "$script" ] && { echo -e "${RED}Error: Python script '$script' does not exist.${RESET}"; return 1; }
    echo -e "${BLUE}Running Python script '$script' with arguments: $*${RESET}"
    python "$script" "$@" | tee "$output_file"
    if [ $? -eq 0 ]; then
        echo -e "${BLUE}Script executed successfully. Output saved to '$output_file'.${RESET}"
    else
        echo -e "${RED}Failure: Some tests failed. Check '$output_file' for details.${RESET}"
    fi
}
# -----------------------------------------------------------------------------
run_pytest() {   # Run pytest on specified test files and save output to pytest.out
    clear
    local test_path="$1"
    local output_file="run.out"
    shift
    
    if [ -z "$test_path" ]; then
        echo -e "${BLUE}Running pytest on current directory with arguments: $*${RESET}"
        pytest "$@" -v 2>&1 | tee "$output_file"
    elif [ -f "$test_path" ] || [ -d "$test_path" ]; then
        echo -e "${BLUE}Running pytest on '$test_path' with arguments: $*${RESET}"
        pytest "$test_path" "$@" -v 2>&1 | tee "$output_file"
    else
        echo -e "${RED}Error: Test path '$test_path' does not exist.${RESET}"
        return 1
    fi
    
    if [ $? -eq 0 ]; then
        echo -e "${BLUE}STests executed successfully. Output saved to '$output_file'.${RESET}"
    else
        echo -e "${RED}Failure: Some tests failed. Check '$output_file' for details.${RESET}"
    fi
}
# -----------------------------------------------------------------------------
run_py() {   # Run Python script and save output to run.out
    clear
    local script_path="$1"
    local output_file="run.out"
    shift
    
    if [ -z "$script_path" ]; then
        echo -e "${RED}Error: No Python script specified.${RESET}"
        return 1
    elif [ -f "$script_path" ]; then
        echo -e "${BLUE}Running Python script '$script_path' with arguments: $*${RESET}"
        python "$script_path" "$@" 2>&1 | tee "$output_file"
    else
        echo -e "${RED}Error: Python script '$script_path' does not exist.${RESET}"
        return 1
    fi
    
    if [ $? -eq 0 ]; then
        echo -e "${BLUE} Python Script executed successfully. Output saved to '$output_file'.${RESET}"
    else
        echo -e "${RED}Failure: Script failed. Check '$output_file' for details.${RESET}"
    fi
}
# -----------------------------------------------------------------------------
run_cmd() {   # Run any shell command and save output to cmd.out
    clear
    local cmd="$1"
    local output_file="run.out"
    shift
    [ -z "$cmd" ] && { echo -e "${RED}Error: No command specified.${RESET}"; return 1; }
    echo -e "${BLUE}Running command: $cmd $*${RESET}"
    # Run command and capture output
    $cmd "$@" 2>&1 | tee "$output_file"
    local exit_status=${PIPESTATUS[0]}
    if [ $exit_status -eq 0 ]; then
        echo -e "${GREEN}Success: Command executed successfully. Output saved to '$output_file'.${RESET}"
    else
        echo -e "${RED}Failure: Command failed with exit code $exit_status. Check '$output_file' for details.${RESET}"
    fi
    return $exit_status
}
# -----------------------------------------------------------------------------
change_prompt() {   # Change the shell prompt to show project name
    #local current_dir=$(basename "$PWD")
    prompt_prefix=${PROJECT_NAME:-"NONE"}
    export PROMPT="($prompt_prefix) %~> "
}
# -----------------------------------------------------------------------------
## PYENV
# Install PYENV and .env both
# brew install pyenv
export PYENV_ROOT="$HOME/.pyenv"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init - zsh)"
# -----------------------------------------------------------------------------
mypy() {   # Display Python environment information
    echo -e "${BLUE}Python should be managed by pyenv${RESET}"
    pyenv_version=$(pyenv --version 2>&1)
    echo -e "${BLUE}Pyenv version: $pyenv_version${RESET}"
    python_path=$(which python)
    python_version=$(python --version 2>&1)
    echo -e "${BLUE}Python executable: $python_path${RESET}"
    echo -e "${BLUE}Python version: $python_version${RESET}"
    pip_path=$(which pip)
    pip_version=$(pip --version 2>&1)
    echo -e "${BLUE}Pip executable: $pip_path${RESET}"
    echo -e "${BLUE}Pip version: $pip_version${RESET}"
    if [ -z "$VIRTUAL_ENV" ]; then
        echo -e "${BLUE}No virtual environment is currently activated.${RESET}"
    else
        echo -e "${BLUE}Current virtual environment: $VIRTUAL_ENV${RESET}"
    fi
}

# -----------------------------------------------------------------------------
go_project() {   # Navigate to a project directory and set up its environment
    [ -z "$1" ] && { echo -e "${RED}Error: No project name provided.${RESET}"; return 1; }
    local project_name="$1"
    [ ! -d "$WORK/$project_name" ] && { echo -e "${RED}Error: Project '$project_name' does not exist under $WORK.${RESET}"; return 1; }
    if [ -n "$PROJECT_NAME" ]; then
        echo -e "${BLUE}Deactivating current project: $PROJECT_NAME${RESET}"
        deactivate 2>/dev/null || echo -e "${BLUE}No virtual environment to deactivate.${RESET}"
        unset PROJECT_NAME
    fi
    cd "$WORK/$project_name" || return 1
    [ -f venv/bin/activate ] && source venv/bin/activate
    [ -f "${project_name}.env" ] && source "${project_name}.env"
    mypy
    if [[ "$TERM_PROGRAM" != "vscode" ]]; then
        [ -f "$project_name".code-workspace ] && code "$project_name".code-workspace
    fi
    export PROJECT_NAME="$project_name"
    change_prompt
}
# -----------------------------------------------------------------------------
gen_project_aliases() {   # Generate aliases for all projects in the WORK directory
    echo -e "${BLUE}Generating project aliases ${RESET}"
    for dir in "$WORK"/*/; do
        [ -d "$dir" ] || continue
        project_name=$(basename "$dir")
        alias "go-$project_name"="go_project $project_name"
     #   echo "  go-$project_name: $WORK/$project_name"
    done
}

list_project_aliases() {   # List all available project aliases
    echo -e "${BLUE}Available project aliases:${RESET}"
    alias | grep "go-" | sed 's/^alias //; s/=.*$//' | sort | while read -r alias_name; do
        project_name=${alias_name#go-}
        echo "   ${BLUE} $alias_name ${RESET} â†’ $WORK/$project_name"
    done
}
# -----------------------------------------------------------------------------
# Lets reconfigure alias to open file with Vscode when inside the vscode terminal
alias open &>/dev/null && unalias open
[[ "$TERM_PROGRAM" == "vscode" ]] && alias open="code"
# -----------------------------------------------------------------------------
# Adding functions to autogenerate aliases
gen_project_aliases
# -----------------------------------------------------------------------------
# Source bash utility functions if available
if [ -f "$BASH_UTILS_SRC/util_bash.sh" ]; then
    source "$BASH_UTILS_SRC/util_bash.sh"
    echo -e "${BLUE}Bash function management util loaded ${RESET}"
else
    echo -e "${RED}Bash function management util is not available${RESET}"
fi
# -----------------------------------------------------------------------------
# Final setup
[ -d "$WORK" ] && cd "$WORK" || cd "$HOME"
PROMPT="%n@%m:%~> "
echo -e "${GREEN}Loaded amit's alias file${RESET}"
# -----------------------------------------------------------------------------